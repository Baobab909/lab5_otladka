# Лабораторная работа №5: Отладка кодовой базы проекта терминала на Python

## Ошибка 1 - ошибка границы цикла (off-by-one)
**Место:** `main.py`, строка 72, блок обработки команды `mv`

**Симптом:** При вводе команды `mv` с двумя аргументами возникает ошибка `IndexError: list index out of range`.

**Как воспроизвести:**
- Запустить терминал: `python main.py`
- Ввести команду: `mv file1.txt file2.txt`

**Отладка:**
- Установить breakpoint на строке: `if len(parts) >= 2:`
- В отладчике видно, что `parts = ['mv', 'file1.txt', 'file2.txt']` и `len(parts) = 3`
- Программа входит в условие, но при обращении к `parts[2]` возникает IndexError

**Причина:** Проверка `len(parts) >= 2` позволяет войти в условие, но для команды `mv` нужны минимум 3 элемента.

#### Исправление:
**Заменено на:**
```python
if len(parts) >= 3:
    source = parts[1]
    destination = parts[2]
    mv(source, destination)
```
    
**Доказательства:**
- proof.proof1

## Ошибка 2 - неверное логическое условие
**Место:** `bug1_ls.py`, строка 24, блок обработки команды `ls()`

**Симптом:** При вводе команды `ls -l` выводится простой список вместо детального с информацией о правах доступа, размере и времени изменения `.

**Как воспроизвести:**
- Запустить терминал: `python main.py`
- Ввести команду: `ls -l`

**Отладка:**
- Установить breakpoint на строке: `if arg == '-l:`
- В отладчике видно, что `arg == '-l` имеет значение `True`, но тип - строка
- При пошаговом выполнении программа пропускает блок детального вывода и переходит к простому списку

**Причина:** Функция получает строку `-l` в параметре arg, но проверка arg == `-l` сравнивает булево значение `True` со строкой, что всегда дает `False`.

#### Исправление:
**Заменено на:**
```python
if arg:
    # детальный вывод с информацией
else:
    # простой вывод
```
    
**Доказательства:**
- proof.proof2


## Ошибка 3 - изменение пользовательской коллекции во время итерации
**Место:** `bug1_ls.py`, строка 19, блок обработки команды `ls()`

**Симптом:** При наличии скрытых файлов (начинающихся с точки) не все файлы отображаются в списке, некоторые пропускаются.

**Как воспроизвести:**
- Создать несколько файлов
- Запустить терминал: `python main.py`
- Ввести команду: `ls -l`

**Отладка:**
- Установить breakpoint на строке: fails.remove(i)
- В отладчике видно, что после удаления .-.txt из списка fails, итератор продолжает по индексу 1, но теперь там находится file2.txt
- Файл file2.txt пропускается в выводе

**Причина:** Изменение списка во время итерации по нему приводит к сдвигу индексов и пропуску элементов.
#### Исправление:
**Заменено на:**
```python
# Создаем новый список без скрытых файлов
visible_files = [f for f in fails if not f.startswith(".")]
for i in visible_files:
    # обработка каждого файла
```
    
**Доказательства:**
- proof.proof3



## Ошибка 4 - использование изменяемого значения по умолчанию
**Место:** `bug2_cat.py`, строка 7, функция `read_file_with_cache()`

**Симптом:** При чтении разных файлов и последующем изменении одного из них, программа продолжает показывать старое содержимое из кэша для всех файлов.
**Как воспроизвести:**
- Создать файл: echo "Первая версия" > file1.txt
- Запустить терминал: python main.py
- Ввести: cat file1.txt
- Изменить файл: echo "Вторая версия" > file1.txt
- Ввести снова: cat file1.txt

**Отладка:**
- Установить breakpoint в функции read_file_with_cache()
- В отладчике видно, что словарь cache сохраняется между вызовами разных файлов
- При втором вызове read_file_with_cache("file1.txt") значение возвращается из кэша без повторного чтения файла

**Причина:** Словарь как значение по умолчанию параметра функции является общим для всех вызовов функции, что приводит к некорректному кэшированию.
#### Исправление:
**Заменено на:**
```python
def read_file_with_cache(file_path, cache=None):
    if cache is None:
        cache = {}  # Создаем новый словарь при каждом вызове
    if file_path not in cache:
        with open(file_path, 'r', encoding='utf-8') as f:
            cache[file_path] = f.read()
    return cache[file_path]
```
    
**Доказательства:**
- proof.proof4


## Ошибка 5 - перехват слишком общего исключения
**Место:** `bug3_rm.py`, строка 54, функция `rm()`

**Симптом:** При различных ошибках удаления (нет прав, файл занят другой программой, диск защищен от записи) выводится одинаковое сообщение "Что-то пошло не так" без указания конкретной причины.
**Как воспроизвести:**
- Попробовать удалить системный файл: rm /etc/passwd
- Попробовать удалить файл, открытый в другой программе
- Попробовать удалить файл на защищенном от записи носителе

**Отладка:**
- Установить breakpoint на строке: except:
- Создать различные ситуации с ошибками удаления
- В отладчике видно, что все исключения перехватываются, но тип и сообщение об ошибке теряются

**Причина:** Пустой блок except: перехватывает все исключения, включая системные, без возможности их анализа и логирования.
#### Исправление:
**Заменено на:**
```python
except PermissionError as e:
    print(f"Ошибка прав доступа: {e}")
    p_error(f"Ошибка прав доступа: {e}")
    return False
except OSError as e:
    print(f"Системная ошибка: {e}")
    p_error(f"Системная ошибка: {e}")
    return False
except Exception as e:
    print(f"Неизвестная ошибка при удалении: {e}")
    p_error(f"Неизвестная ошибка при удалении: {e}")
    return False
```
    
**Доказательства:**
- proof.proof5